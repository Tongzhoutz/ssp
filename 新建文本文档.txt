# MS面经

https://leetcode-cn.com/circle/discuss/NomXXq/



34 获取⽤键盘输⼊常⽤的两种⽅法

```java
Scanner input = new Scanner(System.in);
String s = input.nextLine();
input.close();
```



```java
BufferedReader input = new BufferedReader(new
InputStreamReader(System.in));
String s = input.readLine();
```



# labuladong

## Todo

[51.N皇后（困难）](https://leetcode-cn.com/problems/n-queens)：八皇后问题



[76.最小覆盖子串（困难）](https://leetcode-cn.com/problems/minimum-window-substring)， https://leetcode-cn.com/problems/minimum-window-substring/submissions/，有问题

[567.字符串的排列（中等）](https://leetcode-cn.com/problems/permutation-in-string)

[438.找到字符串中所有字母异位词（中等）](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string)

[3.无重复字符的最长子串（中等）](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)



## 0章节

### 回溯算法

一般的复杂度：O(n!)，因为免不了穷举

[46.全排列（中等）](https://leetcode-cn.com/problems/permutations)

[51.N皇后（困难）](https://leetcode-cn.com/problems/n-queens)：八皇后问题

```python
result = []
# 孙: 原文def backtrack(路径，选择列表): 没有我这里好理解
def backtrack(选择列表，路径):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```



[46.全排列（中等）](https://leetcode-cn.com/problems/permutations)

```java
List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> permute(int[] nums) {

    // 路径：
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(nums, track);
    return res;
}

public void backtrack(int[] nums, LinkedList<Integer> track){
    if(track.size() == nums.length){
        // 注意返回 添加对象引用，而不是新对象引用的错误
        res.add(new LinkedList<Integer>(track));      // res.add(track);
        return;
    }

    for(int i=0; i<nums.length; i++){
        if(track.contains(nums[i])){
            continue;
        }

        track.add(nums[i]);
        backtrack(nums, track);
        track.removeLast();   // remove(int index) remove(Object obj) removeLast()
    }
}
```



[51.N皇后（困难）](https://leetcode-cn.com/problems/n-queens)：cpp写的

string s(num,c) //生成一个字符串，包含num个c字符  

// Create a vector of size n with all values as 10

vector<int> vect(n, 10);

```java
public List<List<String>> solveNQueens(int n) {
    return sunla_start(n);
}

public List<List<String>> sunla_start(int n){
    char[][] pan = new char[n][n];

    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            pan[i][j] = '.';
        }
    }
    List<List<String>> res = new LinkedList<>();
    sunla_start_backtrack(res, pan, 0);
    return res;
}

public void sunla_start_backtrack(List<List<String>> res, char[][] pan, int row){
    int size = pan.length;
    if(row == size){
        List<String> track = new LinkedList<>();
        for(int i=0; i<row; i++){
            track.add(new String(pan[i]));
        }
        res.add(track);
        return;
    }

    for(int col=0; col<size; col++){
        if(!isValid(pan, row, col))
            continue;    // 一个break, 调试了2小时。hhhhh
        pan[row][col]='Q';
        sunla_start_backtrack(res, pan, row+1);
        pan[row][col]='.';
    }
}

public boolean isValid(char[][] pan, int row, int col){
    int size = pan.length;

    for(int i=0; i<row; i++){
        if(pan[i][col]=='Q') return false;
    }

    for(int i=row-1, j=col+1; i>=0&&j<size; i--, j++){
        if(pan[i][j]=='Q') return false;
    }

    for(int i=row-1, j=col-1; i>=0&&j>=0; i--, j--){
        if(pan[i][j]=='Q') return false;
    }

    return true;
}
```

###  BFS 框架

[111.二叉树的最小深度（简单）](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)

[752.打开转盘锁（中等）](https://leetcode-cn.com/problems/open-the-lock)



```java
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数          -----------------------> A

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;              ------------------------->B：A的初值，和step是否需要其他处理
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```



[111.二叉树的最小深度（简单）](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)

```java
public int sunla_bfs(TreeNode root){
    if(root==null) return 0;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int step=1;

    while(queue.size()!=0){
        int sz = queue.size();
        while(sz-- >0){
            TreeNode tmp = queue.poll();
            if(tmp.left==null && tmp.right==null){
                return step;
            }

            if(tmp.left!=null) queue.add(tmp.left);
            if(tmp.right!=null) queue.add(tmp.right);
        }
        step++;
    }

    return step;
}
```





![image-20201230224611147](算法模板.assets/image-20201230224611147.png)

[752.打开转盘锁（中等）](https://leetcode-cn.com/problems/open-the-lock)

```java
public int sunla_main(String[] deadends, String target){
    Queue<String> queue = new LinkedList<>();
    queue.add("0000");

    List<String> deadends_list = Arrays.asList(deadends);
    // sun: 我的版本，会跳过这个异常判断
    if(deadends_list.contains("0000")) return -1;

    Set<String> visited = new HashSet<>();
    visited.add("0000");
    int step=0;

    while(queue.size()!=0){
        int sz = queue.size();
        while(sz-- >0){
            String tmp = queue.poll();

            if(tmp.equals(target))
                return step;

            for(int j=0; j<4; j++){
                String min = minusOne(tmp, j);
                if(visited.contains(min) || deadends_list.contains(min))
                    continue;    
                queue.add(min);
                visited.add(min);
            }

            for(int j=0; j<4; j++){
                String max = plusOne(tmp, j);
                if(visited.contains(max) || deadends_list.contains(max))
                    continue;
                queue.add(max);
                visited.add(max);
            }
        }

        step++;
    }

    return -1;
}

public String minusOne(String s, int j){
    char[] c=s.toCharArray();
    if(c[j]=='0'){
        c[j]='9';
    }else
        c[j] = (char)(c[j] -1);
    return new String(c);
}

public String plusOne(String s, int j){
    char[] c=s.toCharArray();
    if(c[j]=='9'){
        c[j]='0';
    }else
        c[j] = (char)(c[j]+1);
    return new String(c);
}
```



### 二分

左右边界：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array

```
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 最后要检查 left 越界的情况，即target > all
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}


int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 最后要检查 right 越界的情况，即target < all
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```



### 滑动窗口

https://leetcode-cn.com/problems/minimum-window-substring/submissions/

```java
public String window2(String pattern, String str){
    // need：统计pattern,  pattern 中需要的每个字符的个数
    // window: 统计窗口  && need中出现的字符的个数
    int[] need = new int[128];
    int[] window = new int[128];
    int need_count=0;
    for(char c:pattern.toCharArray()){
        // 出错1，未理解valid 和 distinct pattern的关系
        if(need[c] == 0)  need_count++;
        need[c]++;
    }

    int left = 0, right = 0;
    int valid = 0, len= Integer.MAX_VALUE , start=0;
    while(right < str.length()){
        char in = str.charAt(right);
        right++;

        if(need[in] !=0){
            window[in]++;
            if(window[in] == need[in]){
                valid++;
            }
        }

        // 出错2: pattern.length()
        while( valid == need_count ){

            // 出错3: need_count
            if(right - left < len){
                start = left;
                len = right - left;
            }

            char out = str.charAt(left);
            left++;

            if(need[out] !=0){
                if(window[out] == need[out ]){
                    valid--;
                }
                window[out]--;
            }
        }

    }

    return len==Integer.MAX_VALUE?"": str.substring(start, start + len);
}
```





# 排序



# 搜索

## 二分

```java
public int sunp_binarySearch(int[] nums, int target){
    // int l=0, r=nums.length;
    // while( l<r ){
        
    int l=0, r=nums.length -1;
    while(l <= r){
        int mid = (l+r)>>1;        
        if(nums[mid] > target){
            r = mid - 1;
        }else if(nums[mid] ==target){
            return mid;
        }else{
            l = mid + 1;
        }
    }
    return r;
 }
```



# 排序

## 快排

一次partition：选定一个标的X，把所有比X小的数都移到X左边去，把所有比X大的数都移到X右边去。

整体流程：对数组V进行一次partition，得到V(内含V1、X、V2)，其中X已移动到其应该在的位置，再递归地对V1和V2进行partition操作。

```java
public int partion(int[] arr, int left , int right){
    // 不判断 left > right 的原因，因为不可能，起码都是 == 号
    int x = arr[left];
    while(left<right){
        while(left < right && arr[right] >= x) --right;
        arr[left] = arr[right];

        while(left < right && arr[left] <= x) left++;
        arr[right] = arr[left];
    }
    arr[left] = x;
    return left;
}

public void quickSort(int[] arr, int left, int right){
    if(left<right){
        int i = partion(arr, left, right);
		quickSort(arr, left, i - 1);
		quickSort(arr, i + 1, right);
    }
}
```

## 归并排序

```java
public  void merge(int[] arr,int low,int mid,int high,int[] tmp){
    int i = 0;
    int j = low,k = mid+1;  //左边序列和右边序列起始索引
    while(j <= mid && k <= high){
        if(arr[j] < arr[k]){
            tmp[i++] = arr[j++];
        }else{
            tmp[i++] = arr[k++];
        }
    }
    //若左边序列还有剩余，则将其全部拷贝进tmp[]中
    while(j <= mid){    
        tmp[i++] = arr[j++];
    }

    while(k <= high){
        tmp[i++] = arr[k++];
    }
	
    // 拷贝 tmp 中的数据 到 arr中
    for(int t=0;t<i;t++){
        arr[low+t] = tmp[t];
    }
}

public void mergeSort(int[] arr,int low,int high,int[] tmp){
    if(low<high){
        int mid = (low+high)/2;
        mergeSort(arr,low,mid,tmp); //对左边序列进行归并排序
        mergeSort(arr,mid+1,high,tmp);  //对右边序列进行归并排序
        merge(arr,low,mid,high,tmp);    //合并两个有序序列
    }
}
```



## [十大排序](https://www.cnblogs.com/onepixel/p/7674659.html)



# 树

## 前序迭代

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)



### 前中后统一版

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    if (root == null)   return res;

    Deque<TreeNode> stack = new LinkedList<TreeNode>();
    TreeNode node = root;
    while (!stack.isEmpty() || node != null) {
        while (node != null) {
            res.add(node.val);    // 后序 res.addFirst(root.val);  对应处理1
            stack.push(node);
            node = node.left;     // 后序 node = node.right;  对应处理2 
        }
        node = stack.pop();
        node = node.right;        // 后序 node = node.left;  对应处理2
    }
    return res;
}
```



### 深度遍历

```java
// 前序遍历
// 前中后是深度遍历的1种，以下是深度遍历的典型写法
public List<Integer> sunp_preOrder_inter(TreeNode root){
    List<Integer> res = new LinkedList<>();

    if(root==null) return res;

    Deque<TreeNode> stack = new LinkedList<>(){{ push(root); }};
    while(stack.size()!=0){
        TreeNode tmp = stack.pop();
        res.add(tmp.val);
        if(tmp.right != null) stack.push(tmp.right);
        if(tmp.left != null) stack.push(tmp.left);
    }

    return res;
}
```





## 中序迭代

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```java
public List<Integer> Iter(TreeNode root){
    List<Integer> res = new LinkedList<>();
    Deque<TreeNode> stack = new LinkedList<>(){{ add(root); }};

    // 当 root != null 或者 栈不空(此时最近更新的root为null)
    //  - 指针可以左下角走动，就往左下角走动。这是在访问 左重孙
    //  - 获取可以访问的节点，就从stack中获取
    //  - 最后root指向非空左下角节点的右儿子。
    while(root!=null || !stack.empty()){
        
        while(root != null){  //  - 指针可以左下角走动，就往左下角走动
            stack.push(root);
            root = root.left;
        }
        
        root = stack.pop();  //  - 获取可以访问的节点，就从stack中获取
        res.add(root.val);
        root = root.right;  //  - 最后root指向非空左下角节点的右儿子。
    }
    return res;
}
```



## 后续迭代

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

解释说明：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/die-dai-jie-fa-shi-jian-fu-za-du-onkong-jian-fu-za/



前序遍历顺序为：根 -> 左 -> 右

后序遍历顺序为：左 -> 右 -> 根

如果1： 我们将前序遍历中节点插入结果链表尾部的逻辑，==修改为将节点插入结果链表的头部==

​	那么结果链表就变为了：右 -> 左 -> 根

如果2： 我们将遍历的顺序由  ==从左到右  修改为从右到左==，配合如果1

​	那么结果链表就变为了：左 -> 右 -> 根

这刚好是后序遍历的顺序

基于这两个思路，我们想一下如何处理：

1. 修改前序遍历代码中，节点写入结果链表的代码，将插入队尾修改为插入队首

2. 修改前序遍历代码中，每次先查看左节点再查看右节点的逻辑，变为先查看右节点再查看左节点




```java
public List<Integer> Iter(TreeNode root){
    LinkedList<Integer> res = new LinkedList<>();
    Deque<TreeNode> stack = new LinkedList<>(){{ add(root); }};

    while(root!=null || !stack.empty()){
        while(root != null){ 
            res.addFirst(root.val);  // 前序 res.add(root.val);  对应处理1
            stack.push(root);
            root = root.right;       // 前序 root = root.right;  对应处理2
        }

        root = stack.pop();  
        
        root = root.left;  			 // 前序 root = root.right;
    }
    return res;
}
```





## 层序迭代

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```xml
[
  [3],
  [9,20],
  [15,7]
]
```

```java
public List<List<Integer>> levelOrder(TreeNode root){
    List<List<Integer>> res = new ArrayList<List<Integer>>();
    if(root == null)  return res;

    Queue<TreeNode> queue = new LinkedList<>(){{ addLast(root); }};
    while(queue.size()!=0){
        List<Integer> temp = new ArrayList<>();
        int size = queue.size();
        for(int i=0; i<size; i++){
            // 队列头结点，是上层结点
            TreeNode one = queue.poll();
            temp.add(one.val);

            if(one.left != null ) queue.add(one.left);
            if(one.right != null) queue.add(one.right);
        }
        res.add(temp);
    }
    return res;
}
```



# 动态规划

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```java
public int sung_from_left(int[] prices){
    int min=Integer.MAX_VALUE, res=0;
    for(int i=0; i<prices.length; i++){
        if(min<prices[i]){
            res = (prices[i]-min > res)? prices[i]-min : res;
        }else
            min = prices[i];
    }

    return res;
}
```



[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

```java
// 会超时，从最终问题，分析其前1个状态，和最终状态之间的关系，入手
public int sunp_tanxin(int[] nums){
    // 因为总是可达，所以不必判断异常，
    int position = nums.length -1;
    int steps = 0;
    while(position != 0){ 
        for(int i=0; i<position; i++){  //  如果能找到 最近的位置，就找到最近的位置
            if(nums[i] + i >= position){
                steps++;
                position = i;
                break;
            }
        }
    }
    return steps;
}

// dp: 从小问题，到大问题，求得最终解
public int sunp_dp(int[] nums){
    int start = 0;
    int end = 0;
    int next_max = 0;
    int steps = 0;
    // [2,3,1,1,4]的推理区间为 [0,0] ->[1,2] ->[3,4] ，故是两步
    while(end < nums.length - 1){
        for(int i=start; i<=end; i++){
            next_max = Math.max(next_max, i+nums[i]);  // eg, 在[0,0]区间，下次最远到达那个区间
        }
        start = end + 1;   // 更新最远区间为[end+1, next_max]
        end = next_max; 
        steps++;
    }

    return steps;
}
```



### 最长汇文子串

[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```java
public String sung_dp(String s){
    int n = s.length();
    boolean[][] dp = new boolean[n][n];
    String res ="";

    // l = length，是 j - i之间的距离，从[0, n-1]
    for(int l=0; l<n; l++){
        for(int i=0; i+l<n; i++){ // i从0开始，依次根据步长为l, 选取j(但j<n)
            int j=i+l;
            if(l==0){
                dp[i][j]=true;
            }else if(l==1){
                dp[i][j] = (s.charAt(i) == s.charAt(j));
            }else{
                dp[i][j] = (s.charAt(i) == s.charAt(j)) && (dp[i+1][j-1]);
            }

            if(dp[i][j] && l+1 >res.length()){
                // res = [i, j+l+1)
                res = s.substring(i, i+l+1);
            }
        }
    }  
    return res;
}
```



### 最长递增子列

```java
public int sung_dp(int[] nums){
    int len = nums.length;
    int resMax = 1;

    // dp[i]: 以nums[i]结尾的，最长递增子序列
    int[] dp = new int[len];
    Arrays.fill(dp, 1);
    for(int i=1; i<len; i++){
        for(int j=i-1; j>=0; j--){
            if(nums[j]< nums[i]){
                dp[i] = dp[j]+1>dp[i]?dp[j]+1: dp[i];
            }
        }
        resMax = dp[i]>resMax?dp[i]:resMax;
    }
    return resMax;
}
```



# 其他

## 数组长度的判定

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {    
    if(preorder==null || preorder.length == 0) return null;
}
```



```java
if (grid == null || grid.length == 0 || grid[0].length == 0) {
    return 0;
}

int[][] grid1 = null;
int[][] grid2 = new int[0][5];
int[][] grid3=new int[3][0];
if(grid1 == null)
    System.out.println("1111111111111");
if(grid2.length == 0)
    System.out.println("222222222222222222");
if(grid3[0].length==0)
    System.out.println("33333333333333333333");
```



## 合并两个数组

public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 代码解释: 　　

Object src : 原数的起始位置开始 　　

Object dest : 目标数组 　　

int destPos : 目标数组的开始起始位置 　　

int length : 要copy的数组的长

组数据 

```java
byte[] srcBytes = new byte[]{2,4,0,0,0,0,0,10,15,50}; // 源数组

byte[] destBytes = new byte[5]; // 目标数组
	
System.arrayCopy(srcBytes,0,destBytes ,0,5) // 上面这段代码就是 : 创建一个一维空数组,数组的总长度为 12位,然后将srcByt 位之间的数值 copy 到 destBytes目标数组中,在目标数组的第0位开始放置. 那么这行代码的运行效果应该是 2,4,0,0,0,
```



## 比特位计数 

method3： r(2)可以由r(i>>1)+1推到出来m4:

method4：`p(x) = p(x&(x-1))` 推到出来将x的最右边的1消去，`x&(x-1)`的值一定已经存在了，故而可以用`p(x&(x-1))+1`计算出`p(x)`



## LinkedList栈

LinkedList stk = new LinkedList();

```java
用stk.push()和pop()是标准的栈操作
- push表示的是：此方法相当于addFirst(E) 
- - pop相当于：此方法相当于removeFirst() 。用stk.addLast()和stk.removeLast()是另一种章操作
```



Integer之间的比较，建议用 equals()



int[], int[][]的返回：

> new int[]{a,b}
>
> new int[0];



Arrays 和 Collections 用的什么底层排序算法

`Arrays.sort()` 方法： 如果arr.length >=28 && 连续性好的话，用归并排序 如果 arr.length >=286 && 连续性不好的话，用双轴快速排序 如果 arr.length >= 47 && arr.length <286，用双轴快速排序 如果 arr.length < 47，用插入排序。

`Collections.sort()`方法： 如果LegacyMergeSort.userRequested为true的话就会使用归并排序





# SQL算法

SQL：人数最多的5个部门

```sql
select class.id,class.name,count(stu.id) 
from class join stu on class.id=stu.classid
group by class.id order by count(stu.id) desc
```

